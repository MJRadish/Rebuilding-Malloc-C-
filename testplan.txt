Memgrind Test E:
Test E is very similar to test case D, but instead of randomly mallocing 1-64 bytes, test E randomly mallocs 500-1000 bytes. We decided to implement this because we were curious in how the system behaves with large chunks of memory allocation. So the worst case scenario would be the system can be allowed to malloc 5 times, thus hitting the cap of memblock. We wanted to observe this behavior and see how many frees were required to effectively allocated 150 times.

Memgrind Test F:
Test F is also very similar to test case D, but instead of mallocing just a char, it will malloc either a char, int, or a double depending on a random value, then malloc 1-64 bytes randomly of the chosen data type. We specifically wanted to implement this because every other test case just sticks with mallocing char pointers. We wanted to observe how my_malloc() behaves with other data types. We realized that the only difference between each of these data types is that double is 8 times larger than a char and integer is 4 times larger than a char, however we still wanted to see the likelyhood of the same address being returned. If the same address is being returned, then a Node is not created, but since these data types vary largely in size, the likelihood of this happening would be small. We wanted to test if our hypothesis was indeed correct.
